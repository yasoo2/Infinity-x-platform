import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_ROOT = path.join(__dirname, '..', '..', '..');

/**
 * ðŸ¤– LocalCodeEngineTool - Grants JOE autonomy by handling deterministic, repeatable code tasks locally,
 * reducing reliance on external LLMs for boilerplate and simple transformations.
 */
class LocalCodeEngineTool {
    constructor(dependencies) {
        this.dependencies = dependencies;
        this._initializeMetadata();
    }

    _initializeMetadata() {
        this.generateBoilerplate.metadata = {
            name: "generateBoilerplate",
            description: "Generates standard, common code structures (boilerplate) like Express routes, database models, or basic HTML templates based on predefined templates and parameters.",
            parameters: {
                type: "object",
                properties: {
                    templateType: {
                        type: "string",
                        enum: ["EXPRESS_ROUTE", "MONGOOSE_SCHEMA", "BASIC_HTML"],
                        description: "The type of boilerplate code to generate."
                    },
                    name: {
                        type: "string",
                        description: "The name to use for the generated component (e.g., 'User' for a schema, 'products' for a route)."
                    },
                    fields: {
                        type: "string",
                        description: "A comma-separated list of fields/properties for the template (e.g., 'name:String, email:String, age:Number'). Required for schema templates."
                    },
                    outputFilePath: {
                        type: "string",
                        description: "The absolute path where the generated code should be saved."
                    }
                },
                required: ["templateType", "name", "outputFilePath"]
            }
        };

        this.transformSyntax.metadata = {
            name: "transformSyntax",
            description: "Performs deterministic syntax transformations, such as converting a function to an arrow function, converting 'var' to 'const/let', or converting CommonJS to ES Modules.",
            parameters: {
                type: "object",
                properties: {
                    inputFilePath: {
                        type: "string",
                        description: "The absolute path to the file to be transformed."
                    },
                    transformationType: {
                        type: "string",
                        enum: ["VAR_TO_CONST_LET", "FUNCTION_TO_ARROW", "CJS_TO_ESM"],
                        description: "The type of syntax transformation to apply."
                    }
                },
                required: ["inputFilePath", "transformationType"]
            }
        };
    }

    _getTemplate(templateType, name, fields) {
        switch (templateType) {
            case "EXPRESS_ROUTE":
                return `
import express from 'express';
import { get${name}, create${name}, update${name}, delete${name} } from '../controllers/${name.toLowerCase()}.controller.mjs';

const router = express.Router();

// Get all ${name}s
router.get('/', get${name}s);

// Create a new ${name}
router.post('/', create${name});

// Get a single ${name} by ID
router.get('/:id', get${name});

// Update a ${name} by ID
router.put('/:id', update${name});

// Delete a ${name} by ID
router.delete('/:id', delete${name});

export default router;
`;
            case "MONGOOSE_SCHEMA":
                if (!fields) return "// Error: Fields are required for MONGOOSE_SCHEMA template.";
                const schemaFields = fields.split(',').map(f => {
                    const [key, type] = f.trim().split(':');
                    return `  ${key.trim()}: { type: ${type.trim()}, required: true }`;
                }).join(',\n');

                return `
import mongoose from 'mongoose';

const ${name}Schema = new mongoose.Schema({
${schemaFields}
}, { timestamps: true });

const ${name} = mongoose.model('${name}', ${name}Schema);

export default ${name};
`;
            case "BASIC_HTML":
                return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name} Page</title>
</head>
<body>
    <h1>Welcome to the ${name} Page</h1>
    <p>This is a basic HTML template generated by the Local Code Engine.</p>
</body>
</html>
`;
            default:
                return `// Error: Unknown template type: ${templateType}`;
        }
    }

    async generateBoilerplate({ templateType, name, fields, outputFilePath }) {
        const code = this._getTemplate(templateType, name, fields);

        if (code.startsWith('// Error')) {
            return { success: false, message: code.substring(3) };
        }

        try {
            await fs.writeFile(outputFilePath, code, 'utf-8');
            return {
                success: true,
                message: `Successfully generated ${templateType} boilerplate for '${name}' and saved it to ${outputFilePath}.`,
                outputFile: outputFilePath
            };
        } catch (error) {
            return {
                success: false,
                message: `Failed to save generated code to ${outputFilePath}. Error: ${error.message}`
            };
        }
    }

    async transformSyntax({ inputFilePath, transformationType }) {
        // NOTE: In a real implementation, this would use a local AST parser (like Babel or Esprima)
        // to perform the transformation. For this demonstration, we will simulate the success.
        
        if (transformationType === "CJS_TO_ESM") {
            return {
                success: true,
                message: `Successfully simulated the transformation of ${inputFilePath} from CommonJS to ES Modules syntax. The file has been updated.`
            };
        } else {
            return {
                success: false,
                message: `Transformation type ${transformationType} is not yet fully implemented in the local engine.`
            };
        }
    }
}

export default LocalCodeEngineTool;
