/**
 * üöÄ Advanced Tools Manager (The Executor) - Refactored
 * This is the execution engine of the JOEngine system. It coordinates and executes plans generated by the AIEngine.
 * This version is refactored to work with simple, function-based tools with metadata.
 * 
 * @module AdvancedToolsManager
 * @version 4.0.0
 */

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class AdvancedToolsManager {
    constructor(options = {}) {
        this.toolsDir = options.toolsDir || path.join(__dirname);
        this.availableFunctions = new Map(); // Maps function name to the actual function
        this.functionMetadata = new Map(); // Maps function name to its metadata object
        this.isInitialized = false;

        console.log('‚úÖ Advanced Tools Manager (Executor) v4.0.0 initialized.');
    }

    /**
     * üìÇ Dynamically loads and registers all available tool functions.
     * Reads the tools directory, imports modules, and registers each function with its metadata.
     */
    async loadTools() {
        if (this.isInitialized) return;

        console.log(`üìÇ Loading tools from: ${this.toolsDir}`);

        try {
            const files = await fs.readdir(this.toolsDir);

            for (const file of files) {
                if (file.endsWith('.tool.mjs')) { // Only load our new standardized tool files
                    const toolFilePath = path.join(this.toolsDir, file);
                    try {
                        const toolModule = await import(toolFilePath);
                        const toolFunctions = toolModule.default;

                        if (typeof toolFunctions === 'object' && toolFunctions !== null) {
                            for (const funcName of Object.keys(toolFunctions)) {
                                const func = toolFunctions[funcName];
                                if (typeof func === 'function' && func.metadata) {
                                    if (this.availableFunctions.has(func.metadata.name)) {
                                        console.warn(`‚ö†Ô∏è Warning: Duplicate function name '${func.metadata.name}' detected. Overwriting.`);
                                    }
                                    this.availableFunctions.set(func.metadata.name, func);
                                    this.functionMetadata.set(func.metadata.name, func.metadata);
                                    console.log(`‚úÖ Function loaded: ${func.metadata.name}`);
                                }
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è No valid tool functions object found in ${file}`);
                        }

                    } catch (error) {
                        console.error(`‚ùå Error loading tool file ${file}:`, error);
                    }
                }
            }

            this.isInitialized = true;
            console.log('üëç All tool functions loaded and registered successfully.');

        } catch (error) {
            console.error('‚ùå Critical error loading tools:', error);
            throw new Error('Could not initialize the tool manager.');
        }
    }

    /**
     * üìã Returns a list of all available tools (their metadata) for the planner.
     * @returns {Array<object>} An array of tool metadata objects.
     */
    getAvailableTools() {
        if (!this.isInitialized) {
            console.warn('Getting available tools before initialization.');
        }
        return Array.from(this.functionMetadata.values());
    }

    /**
     * üèÉ‚Äç‚ôÇÔ∏è Executes a structured action plan.
     * This is the core function that receives a JSON plan and executes it step-by-step.
     * 
     * @param {Array<object>} plan - An array of steps, presumably from an AIEngine.
     * @returns {Promise<object>} A summary of the plan's execution results.
     */
    async executePlan(plan) {
        if (!this.isInitialized) {
            await this.loadTools();
        }

        console.log('üöÄ Starting plan execution...');

        const executionResults = {};
        const summary = [];

        for (const step of plan) {
            console.log(`\n‚ñ∂Ô∏è Executing Step ${step.step}: ${step.thought}`);

            const { tool, params } = step; // 'tool' is the function name

            if (!this.availableFunctions.has(tool)) {
                const errorMsg = `Tool function "${tool}" not found.`;
                console.error(`‚ùå ${errorMsg}`);
                summary.push({ step: step.step, status: 'Failed', error: errorMsg });
                return { success: false, summary, results: executionResults };
            }

            try {
                const funcToExecute = this.availableFunctions.get(tool);
                const resolvedParams = this.resolvePlaceholders(params, executionResults);

                console.log(`   - Tool Function: ${tool}`);
                console.log(`   - Params: ${JSON.stringify(resolvedParams, null, 2)}`);

                const result = await funcToExecute(resolvedParams);

                if (result && result.success === false) { // Handle tools that return structured errors
                    throw new Error(result.error || `Tool execution failed with success:false`);
                }

                executionResults[`step${step.step}`] = result;
                const resultMessage = result.message || `Function ${tool} executed.`;
                summary.push({ step: step.step, tool, status: 'Success', result: resultMessage });

                console.log(`‚úÖ Step ${step.step} completed successfully.`);
                console.log(`   - Result: ${JSON.stringify(result, null, 2)}`);

            } catch (error) {
                const errorMsg = `Step ${step.step} (${tool}) failed: ${error.message}`;
                console.error(`‚ùå ${errorMsg}`);
                summary.push({ step: step.step, status: 'Failed', error: errorMsg });
                return { success: false, summary, results: executionResults };
            }
        }

        console.log('\nüéâ Plan execution completed successfully!');
        return { success: true, summary, results: executionResults };
    }

    /**
     * üß© Resolves dependencies between steps.
     * Replaces placeholders (e.g., "result of step 1") with actual results.
     * 
     * @param {object} params - The parameters that might contain placeholders.
     * @param {object} results - The object holding results from previous steps.
     * @returns {object} The parameters with placeholders resolved.
     */
    resolvePlaceholders(params, results) {
        if (!params) return {};
        const resolved = {};
        const placeholderRegex = /result of step (\d+)/i;

        for (const key in params) {
            const value = params[key];

            if (typeof value === 'string') {
                const match = value.match(placeholderRegex);
                if (match && match[1]) {
                    const stepNumber = `step${match[1]}`;
                    if (results[stepNumber]) {
                        console.log(`   - Resolving placeholder: "${value}" with result from ${stepNumber}`);
                        resolved[key] = results[stepNumber];
                    } else {
                        resolved[key] = value;
                    }
                } else {
                    resolved[key] = value;
                }
            } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                resolved[key] = this.resolvePlaceholders(value, results);
            } else {
                resolved[key] = value;
            }
        }
        return resolved;
    }
}

export default AdvancedToolsManager;
