/**\n * üõ†Ô∏è ToolManager - The Dynamic, Self-Aware Tool Engine\n * @version 2.1.0 - Now supports Classes, Factories, and static Objects.\n */\nimport fs from \'fs/promises\';\nimport path from \'path\';\nimport { fileURLToPath } from \'url\';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst TOOLS_DIR = path.join(__dirname, \'..\' , \'..\' , \'..\' , \'src\', \'tools_refactored\');\n\n// Helper to check if a value is a class\nfunction isClass(v) {\n  return typeof v === \'function\' && /^\s*class\s+/.test(v.toString());\n}\n\nclass ToolManager {\n    constructor() {\n        this.tools = new Map();\n        this.toolSchemas = [];\n        this._isInitialized = false;\n    }\n\n    async initialize(dependencies) {\n        if (this._isInitialized) return;\n        console.log(\'üîÑ Initializing ToolManager with dependencies...\');\n\n        const toolFiles = await fs.readdir(TOOLS_DIR);\n\n        for (const file of toolFiles) {\n            if (file.endsWith(\'.mjs\')) {\n                const toolModulePath = path.join(TOOLS_DIR, file);\n                try {\n                    const { default: toolExport } = await import(`file://${toolModulePath}`);\n                    let toolModule;\n\n                    if (isClass(toolExport)) {\n                        // It\'s a class, instantiate it\n                        const toolInstance = new toolExport(dependencies);\n                        toolModule = this._extractToolsFromInstance(toolInstance);\n                    } else if (typeof toolExport === \'function\') {\n                        // It\'s a factory function, call it\n                        toolModule = toolExport(dependencies);\n                    } else if (typeof toolExport === \'object\' && toolExport !== null) {\n                        // It\'s a static tool module\n                        toolModule = toolExport;\n                    } else {\n                        console.warn(`‚ö†Ô∏è Tool file ${file} has an invalid or unhandled export type.`);\n                        continue;\n                    }\n                    \n                    this._registerModule(toolModule);\n\n                } catch (error) {\n                    console.error(`‚ùå Critical Error: Failed to load or process tool file: ${file}`, error);\n                    throw error; // Stop the server on critical tool failure\n                }\n            }\n        }\n\n        this._isInitialized = true;\n        console.log(`‚úÖ ToolManager initialized. ${this.tools.size} tools registered.`);\n    }\n\n    _extractToolsFromInstance(instance) {\n        const tools = {};\n        // Look for methods on the prototype that have metadata\n        for (const propName of Object.getOwnPropertyNames(Object.getPrototypeOf(instance))) {\n            const prop = instance[propName];\n            if (typeof prop === \'function\' && prop.metadata) {\n                tools[propName] = prop.bind(instance);\n                tools[propName].metadata = prop.metadata; // Re-attach metadata\n            }\n        }\n        return tools;\n    }\n\n    _registerModule(module) {\n        for (const [toolName, toolFunction] of Object.entries(module)) {\n            if (typeof toolFunction === \'function\' && toolFunction.metadata) {\n                this.tools.set(toolName, toolFunction);\n                this.toolSchemas.push({ type: \'function\', function: toolFunction.metadata });\n            }\n        }\n    }\n\n    async execute(toolName, args) {\n        if (!this._isInitialized) throw new Error(\'ToolManager not initialized.\');\n        const tool = this.tools.get(toolName);\n        if (!tool) throw new Error(`Tool \"${toolName}\" not found.`);\n        \n        console.log(`-‚ö° Executing tool: ${toolName}`);\n        return tool(args);\n    }\n\n    getToolSchemas() {\n        return this.toolSchemas;\n    }\n}\n\nexport default new ToolManager();\n