/**\n * ðŸ“¡ Quantum Tunnel - Real-time Streaming Service\n * @version 1.0.0\n * @description Manages WebSocket connections and acts as the bridge between the backend event bus\n * and the connected clients. It listens to specific events and relays them in real-time.\n */\n\nimport { WebSocketServer } from 'ws';\nimport eventBus from '../core/event-bus.mjs';\n\nclass RealtimeService {\n    constructor(server) {\n        if (!server) {\n            throw new Error(\'HTTP Server instance is required to initialize RealtimeService.\');\n        }\n        this.wss = new WebSocketServer({ server, path: \'/ws/quantum-tunnel\' });\n        this.clients = new Map(); // Use a map to associate connections with session IDs\n        this.initialize();\n    }\n\n    initialize() {\n        this.wss.on(\'connection\', (ws, req) => {\n            // For now, we\'ll use a simple query parameter for session ID.\n            // In a production system, you might use a more secure token.\n            const url = new URL(req.url, `http://${req.headers.host}`);\n            const sessionId = url.searchParams.get(\'sessionId\');\n\n            if (!sessionId) {\n                console.error(\"[RealtimeService] Connection attempt without a session ID. Closing connection.\");\n                ws.close(1008, \"Session ID is required.\");\n                return;\n            }\n\n            console.log(`[RealtimeService] Client connected for session: ${sessionId}`);\n            this.clients.set(sessionId, ws);\n\n            ws.on(\'close\', () => {\n                console.log(`[RealtimeService] Client disconnected for session: ${sessionId}`);\n                this.clients.delete(sessionId);\n            });\n\n            ws.on(\'error\', (error) => {\n                console.error(`[RealtimeService] WebSocket error for session ${sessionId}:`, error);\n                this.clients.delete(sessionId);\n            });\n\n            ws.send(JSON.stringify({ type: \'system:connected\', message: \'Quantum Tunnel established.\' }));\n        });\n\n        // Listen to events from the central bus and relay them\n        this.listenForEvents();\n\n        console.log(\'ðŸ“¡ Real-time Service (Quantum Tunnel) initialized.\');\n    }\n\n    listenForEvents() {\n        eventBus.on(\'sandbox:data\', ({ sessionId, data }) => {\n            this.send(sessionId, { type: \'sandbox:output\', payload: data });\n        });\n\n        eventBus.on(\'sandbox:error\', ({ sessionId, error }) => {\n            this.send(sessionId, { type: \'sandbox:error\', payload: error });\n        });\n\n        eventBus.on(\'sandbox:exit\', ({ sessionId, code }) => {\n            this.send(sessionId, { type: \'sandbox:exit\', payload: { code } });\n        });\n    }\n\n    send(sessionId, message) {\n        const client = this.clients.get(sessionId);\n        if (client && client.readyState === client.OPEN) {\n            try {\n                client.send(JSON.stringify(message));\n            } catch (error) {\n                console.error(`[RealtimeService] Failed to send message to session ${sessionId}:`, error);\n            }\n        }\n    }\n\n    broadcast(message) {\n        this.clients.forEach((client, sessionId) => {\n            this.send(sessionId, message);\n        });\n    }\n}\n\nexport default RealtimeService;\n