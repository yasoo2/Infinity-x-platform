/**\n * ⚛️ Sandbox Manager - Now with Real-time Event Streaming\n * @version 2.0.0\n * Manages isolated execution environments and now streams process output in real-time\n * via the central event bus, enabling features like live terminal feeds.\n */\n\nimport { spawn } from 'child_process';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport os from 'os';\nimport { v4 as uuidv4 } from 'uuid';\nimport eventBus from './core/event-bus.mjs'; // Import the central nervous system\n\nclass SandboxManager {\n  constructor(options = {}) {\n    this.sandboxDir = options.sandboxDir || path.join(os.tmpdir(), 'infinity-sandbox');\n    // ... other configurations ...\n    this.activeProcesses = new Map();\n  }\n\n  async initialize() {\n    await fs.mkdir(this.sandboxDir, { recursive: true });\n    console.log(`⚛️ Sandbox Manager v2.0 initialized at ${this.sandboxDir}`);\n  }\n\n  /**\n   * Executes a shell command and streams the output in real-time.\n   */\n  async executeShell(command, options = {}) {\n    // A session ID is crucial for routing the output to the correct client.\n    const sessionId = options.sessionId;\n    if (!sessionId) {\n      return Promise.reject(new Error(\'A session ID is required for real-time execution.\'));\n    }\n\n    const timeout = options.timeout || this.timeout || 60000; // 60 seconds\n    const cwd = options.cwd || path.join(this.sandboxDir, sessionId);\n\n    return new Promise(async (resolve, reject) => {\n      let finalOutput = \'\';\n      let finalErrorOutput = \'\';\n\n      try {\n        await fs.mkdir(cwd, { recursive: true });\n\n        const process = spawn('bash', ['-c', command], {\n          cwd,\n          timeout,\n          env: { ...process.env, SANDBOX_SESSION_ID: sessionId }\n        });\n\n        const processId = process.pid;\n        this.activeProcesses.set(processId, process);\n\n        // --- Real-time Streaming --- \n\n        process.stdout.on('data', (data) => {\n          const output = data.toString();\n          finalOutput += output;\n          // Emit the data chunk to the event bus for any service to consume.\n          eventBus.emit(\'sandbox:data\', { sessionId, data: output });\n        });\n\n        process.stderr.on('data', (data) => {\n          const errorOutput = data.toString();\n          finalErrorOutput += errorOutput;\n          // Emit the error chunk to the event bus.\n          eventBus.emit(\'sandbox:error\', { sessionId, error: errorOutput });\n        });\n\n        process.on('close', (code) => {\n          this.activeProcesses.delete(processId);\n          // Announce that the process has finished.\n          eventBus.emit(\'sandbox:exit\', { sessionId, code });\n\n          // The promise still resolves with the full output for services that need it.\n          resolve({\n            code,\n            stdout: finalOutput,\n            stderr: finalErrorOutput,\n            success: code === 0,\n          });\n        });\n\n        process.on('error', (err) => {\n          this.activeProcesses.delete(processId);\n          eventBus.emit(\'sandbox:error\', { sessionId, error: err.message });\n          reject(err);\n        });\n\n      } catch (err) {\n        eventBus.emit(\'sandbox:error\', { sessionId, error: err.message });\n        reject(err);\n      }\n    });\n  }\n\n  // The other methods (writeFile, readFile, executePython, etc.) can remain largely the same,\n  // as they build upon the newly enhanced executeShell method.\n\n  async executePython(code, options = {}) {\n    const sessionPath = path.join(this.sandboxDir, options.sessionId);\n    const scriptPath = path.join(sessionPath, `script_${uuidv4()}.py`);\n    await fs.mkdir(sessionPath, { recursive: true });\n    await fs.writeFile(scriptPath, code);\n    const result = await this.executeShell(`python3 \"${scriptPath}\"`, options);\n    await fs.unlink(scriptPath).catch(()=>{});\n    return result;\n  }\n
  async executeNode(code, options = {}) {\n    const sessionPath = path.join(this.sandboxDir, options.sessionId);\n    const scriptPath = path.join(sessionPath, `script_${uuidv4()}.mjs`);\n    await fs.mkdir(sessionPath, { recursive: true });\n    await fs.writeFile(scriptPath, code);\n    const result = await this.executeShell(`node \"${scriptPath}\"`, options);\n    await fs.unlink(scriptPath).catch(()=>{});\n    return result;\n  }\n
  async writeFile(sessionId, filePath, content) {\n    // ... (implementation remains the same) ...\n  }\n
  async readFile(sessionId, filePath) {\n    // ... (implementation remains the same) ...\n  }\n
  // ... etc ...\n}\n\nexport default SandboxManager;\n