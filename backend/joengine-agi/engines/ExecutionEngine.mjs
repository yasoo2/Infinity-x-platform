/**
 * Execution Engine for JOEngine AGI
 * Responsible for taking a plan from a Reasoning Engine and executing it reliably.
 */

import { executeFunction } from '../../src/services/ai/function-calling.service.mjs';

export class ExecutionEngine {
    constructor() {
        console.log('‚úÖ JOEngine AGI Execution Engine Initialized.');
    }

    /**
     * Executes a plan generated by a Reasoning Engine.
     * @param {object} plan The plan object, containing an array of subtasks.
     * @returns {Promise<{success: boolean, results: any[]}>}
     */
    async executePlan(plan) {
        if (!plan || !plan.subtasks || !Array.isArray(plan.subtasks)) {
            console.error('‚ùå Invalid plan structure provided to Execution Engine.');
            return { success: false, results: [{ error: 'Invalid plan structure' }] };
        }

        console.log(`
üöÄ Starting Execution of Plan: ${plan.description || 'No description'}`)
        console.log(`Total subtasks: ${plan.subtasks.length}`);

        const results = [];
        let overallSuccess = true;

        for (let i = 0; i < plan.subtasks.length; i++) {
            const task = plan.subtasks[i];
            console.log(`
--- Executing Subtask ${i + 1}/${plan.subtasks.length}: ${task.description} ---`);
            console.log(`Tool: ${task.tool}, Function: ${task.function}, Args:`, task.args);

            try {
                // Use the centralized function executor for reliability
                // NOTE: We need to ensure function-calling.service is pointing to the right tools.
                const result = await executeFunction(task.function, task.args);

                if (!result.success) {
                    console.error(`‚ùå Subtask Failed: ${result.error}`);
                    overallSuccess = false;
                    results.push({ subtask: task.description, success: false, error: result.error });
                    break; // Stop execution on failure
                } else {
                    console.log(`‚úÖ Subtask Succeeded.`);
                    results.push({ subtask: task.description, success: true, result: result.result });
                }
            } catch (error) {
                console.error(`‚ùå Unhandled exception during subtask execution: ${error.message}`);
                overallSuccess = false;
                results.push({ subtask: task.description, success: false, error: error.message });
                break; // Stop execution on unhandled exception
            }
        }

        console.log(`
--- Plan Execution Finished ---`);
        console.log(`Final Status: ${overallSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);

        return { success: overallSuccess, results };
    }
}

export default ExecutionEngine;
