import axios from \'axios\';\n\n/**\n * Grok Tool for JOEngine AGI - UPGRADED\n * Features an enhanced, safer refactoring prompt inspired by the legacy Gemini Engine.\n */\nexport class GrokTool {\n  constructor(config) {\n    this.apiKey = config.grokApiKey || process.env.GROK_API_KEY;\n    this.baseURL = \'https://api.x.ai/v1\';\n    this.model = \'grok-1.5-claude-3.5\'; // Hypothetical advanced model\n    this.timeout = 45000;\n  }\n\n  async _executeCompletion(messages) {\n    if (!this.apiKey || this.apiKey.includes(\'your-grok-api-key\')) {\n      throw new Error(\'Grok API key is not configured.\');\n    }\n\n    try {\n      const response = await axios.post(\n        `${this.baseURL}/chat/completions`,\n        {\n          model: this.model,\n          messages,\n          temperature: 0.5, // Lower temperature for more predictable code\n          max_tokens: 4096,\n          stream: false,\n        },\n        {\n          headers: {\n            \'Authorization\': `Bearer ${this.apiKey}`,\n            \'Content-Type\': \'application/json\',\n          },\n          timeout: this.timeout,\n        }\n      );\n      return response.data.choices[0].message.content;\n    } catch (error) {\n      // Enhanced error handling from the original service\n      if (error.response) {\n        const { status, data } = error.response;\n        if (status === 401) throw new Error(\'Grok API key is invalid or expired.\');\n        if (status === 429) throw new Error(\'Grok API rate limit exceeded.\');\n        if (status >= 500) throw new Error(\'Grok server error. Please try again later.\');\n        throw new Error(`Grok API error (${status}): ${data?.error?.message || error.message}`);\n      } else if (error.code === \'ECONNABORTED\') {\n        throw new Error(\'Grok API request timed out.\');\n      }\n      throw new Error(`Failed to connect to Grok: ${error.message}`);\n    }\n  }\n\n  /**\n   * Safely refactors or improves code using a strict, protective prompt.\n   * @param {string} originalCode The code to be improved.\n   * @param {string} command The instruction for improvement.\n   * @returns {Promise<{content: string, message: string}>} The refactored code.\n   */\n  async refactorCode(originalCode, command) {\n    const originalLength = originalCode.length;\n    console.log(`Refactoring code (${originalLength} chars) with command: ${command}`);\n\n    const prompt = `\nØ£Ù†Øª **Ø¬Ùˆ (Joe)** â€” ÙˆÙƒÙŠÙ„ AI Ù…Ø­ØªØ±Ù Ù…ØªØ®ØµØµ ÙÙŠ ØªØ·ÙˆÙŠØ± ÙˆØªØ­Ø³ÙŠÙ† Ø§Ù„ÙƒÙˆØ¯.\n\n**ğŸ¯ Ø§Ù„Ø£Ù…Ø± Ø§Ù„Ù…Ø·Ù„ÙˆØ¨:** ${command}\n\n**ğŸ“„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ:**\n\`\`\`\n${originalCode}\n\`\`\`\n\n**âš ï¸ Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„ØµØ§Ø±Ù…Ø© (CRITICAL - Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø®Ø±Ù‚Ù‡Ø§):**\n1.  **Ø§Ù„Ø­ÙØ§Ø¸ Ø§Ù„ÙƒØ§Ù…Ù„:** Ø§Ø­ØªÙØ¸ Ø¨Ù€ 100% Ù…Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø®Ø·Ø£ Ø¨Ø±Ù…Ø¬ÙŠ ÙˆØ§Ø¶Ø­.\n2.  **Ø¹Ø¯Ù… Ø§Ù„Ø­Ø°Ù:** Ù…Ù…Ù†ÙˆØ¹ Ø­Ø°Ù Ø£ÙŠ Ø¯Ø§Ù„Ø©ØŒ Ù…ØªØºÙŠØ±ØŒ classØŒ HTML elementØŒ Ø£Ùˆ CSS rule.\n3.  **Ø§Ù„Ø¥Ø¶Ø§ÙØ© ÙÙ‚Ø·:** Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø£Ù…Ø± ÙŠØªØ·Ù„Ø¨ Ø¥Ø¶Ø§ÙØ©ØŒ Ø£Ø¶Ù Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ ÙÙ‚Ø· Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯.\n4.  **Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„:** ÙŠØ¬Ø¨ Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ù„Ù ÙƒØ§Ù…Ù„Ø§Ù‹ 100% Ø¨Ø¹Ø¯ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ (Ù„Ø§ Ø§Ø®ØªØµØ§Ø±Ø§Øª).\n5.  **Ø§Ù„Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø£ØµÙ„ÙŠ:** Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù†ÙØ³ Ø§Ù„Ø¨Ù†ÙŠØ©ØŒ Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ØŒ ÙˆØ§Ù„Ù…Ø³Ø§ÙØ§Øª Ù‚Ø¯Ø± Ø§Ù„Ø¥Ù…ÙƒØ§Ù†.\n6.  **Ø§Ù„ØªÙˆØ§ÙÙ‚:** ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯ Ù…ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯.\n\n**ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…Ù‡Ù…Ø©:**\n- Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠ: ${originalLength} Ø­Ø±Ù.\n- ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ù†Ø§ØªØ¬ Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£ØµÙ„ÙŠØŒ Ø¥Ù„Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø£Ù…Ø± ÙŠØ¨Ø±Ø± Ø§Ù„Ø­Ø°Ù.\n\n**ğŸ“¤ ØµÙŠØºØ© Ø§Ù„Ø±Ø¯ (JSON ÙÙ‚Ø·):**\n\`\`\`json\n{\n  \"content\": \"Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø¹Ø¯Ù‘Ù„ Ù‡Ù†Ø§...\",\n  \"message\": \"ÙˆØµÙ Ù…Ø®ØªØµØ± Ù„Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„ØªÙŠ Ù‚Ù…Øª Ø¨Ù‡Ø§.\"\n}\n\`\`\`\n`;\n\n    try {\n      const responseText = await this._executeCompletion([{ role: \'user\', content: prompt }]);\n      const jsonMatch = responseText.match(/{\s*[\\s\\S]*}/);\n      if (!jsonMatch) {\n        throw new Error(\'Grok response did not contain valid JSON.\');\n      }\n\n      const data = JSON.parse(jsonMatch[0]);\n\n      if (!data.content) {\n        throw new Error(\'Parsed JSON response is missing the \'content\' field.\');\n      }\n\n      // Safety Check: Prevent drastic, unintentional code reduction.\n      const newLength = data.content.length;\n      const sizeRatio = newLength / originalLength;\n      if (sizeRatio < 0.7 && !command.toLowerCase().includes(\'remove\') && !command.toLowerCase().includes(\'delete\')) {\n        console.warn(`[GrokTool] Warning: Drastic code reduction (${(sizeRatio * 100).toFixed(1)}%) detected. This might be an error.`);\n        data.message += \" (Warning: significant code size reduction detected)\";\n      }\n\n      data.content = this._cleanCode(data.content);\n      console.log(\'âœ… Code refactored successfully.\');\n      return data;\n\n    } catch (error) {\n      console.error(`[GrokTool] Failed to refactor code: ${error.message}`);\n      // Fallback to prevent breaking the flow: return the original code.\n      return {\n        content: originalCode,\n        message: `Failed to refactor code due to an error: ${error.message}`\n      };\n    }\n  }\n\n  async generateCode(description, codeType = \'javascript\') {\n    const prompt = `As a professional software developer, create a complete, production-ready ${codeType} snippet based on the following description. Respond ONLY with the raw code, without any extra explanations or markdown.\n\n**Description:** ${description}`;
    const code = await this._executeCompletion([{ role: \'user\', content: prompt }]);\n    return this._cleanCode(code);\n  }\n\n  _cleanCode(code) {\n    return code.replace(/^```[a-z]*\\n|\\n```$/g, \'\').trim();\n  }\n}\n\nexport default GrokTool;\n